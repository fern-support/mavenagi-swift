import Foundation

public struct ConversationResponse: Codable, Hashable, Sendable {
    /// Optional configurations for responses to this conversation
    public let responseConfig: ResponseConfig?
    /// The subject of the conversation
    public let subject: String?
    /// The url of the conversation
    public let url: String?
    /// The date and time the conversation was created
    public let createdAt: Date?
    /// The date and time the conversation was last updated
    public let updatedAt: Date?
    /// The tags of the conversation. Used for filtering in Agent Designer.
    public let tags: JSONValue?
    /// The metadata of the conversation supplied by the app which created the conversation.
    public let metadata: [String: String]?
    /// All metadata for the conversation. Keyed by appId.
    public let allMetadata: [String: [String: String]]
    /// The ID that uniquely identifies this conversation
    public let conversationId: EntityId
    /// An analysis of the conversation. Fields are generated by Maven via an analysis of user messages. This object is calculated on a delay. Fields will not be up to date on ask requests.
    public let analysis: ConversationAnalysis
    /// A summary of the conversation. Fields are calculated from conversation data. Unlike analysis, all fields can be derived from other data available in the API. This object is provided as a convenience and is calculated on a delay. Fields will not be up to date on ask requests.
    public let summary: ConversationSummary
    /// Whether the conversation user-specific data has been deleted. See `deleteConversation` for details.
    public let deleted: Bool
    /// Whether the conversation is able to receive asynchronous messages.
    /// Only applicable if a conversation is initialized with the `ASYNC` capability. Defaults to true. Can be closed using the `PATCH` API.
    public let open: Bool
    /// Whether the LLM is enabled for this conversation.
    /// If true, `USER` messages sent via the ask API will be sent to the LLM and a `BOT_RESPONSE` or `BOT_SUGGESTION` message will be generated.
    /// If false, `USER` messages will not be sent to the LLM.
    public let llmEnabled: Bool
    /// Additional context used for simulation runs. When present, this conversation is treated as a simulation. 
    /// Simulation conversations are excluded from normal search results unless explicitly included via the `simulationFilter` field.
    public let simulationContext: SimulationContext?
    /// The messages in the conversation
    public let messages: [ConversationMessageResponse]
    /// The attachments associated with this conversation. Additional attachments may be associated to individual messages.
    /// 
    /// Message attachments are included in LLM context, conversation attachments are not.
    public let attachments: [AttachmentResponse]
    /// Additional properties that are not explicitly defined in the schema
    public let additionalProperties: [String: JSONValue]

    public init(
        responseConfig: ResponseConfig? = nil,
        subject: String? = nil,
        url: String? = nil,
        createdAt: Date? = nil,
        updatedAt: Date? = nil,
        tags: JSONValue? = nil,
        metadata: [String: String]? = nil,
        allMetadata: [String: [String: String]],
        conversationId: EntityId,
        analysis: ConversationAnalysis,
        summary: ConversationSummary,
        deleted: Bool,
        open: Bool,
        llmEnabled: Bool,
        simulationContext: SimulationContext? = nil,
        messages: [ConversationMessageResponse],
        attachments: [AttachmentResponse],
        additionalProperties: [String: JSONValue] = .init()
    ) {
        self.responseConfig = responseConfig
        self.subject = subject
        self.url = url
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.tags = tags
        self.metadata = metadata
        self.allMetadata = allMetadata
        self.conversationId = conversationId
        self.analysis = analysis
        self.summary = summary
        self.deleted = deleted
        self.open = open
        self.llmEnabled = llmEnabled
        self.simulationContext = simulationContext
        self.messages = messages
        self.attachments = attachments
        self.additionalProperties = additionalProperties
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.responseConfig = try container.decodeIfPresent(ResponseConfig.self, forKey: .responseConfig)
        self.subject = try container.decodeIfPresent(String.self, forKey: .subject)
        self.url = try container.decodeIfPresent(String.self, forKey: .url)
        self.createdAt = try container.decodeIfPresent(Date.self, forKey: .createdAt)
        self.updatedAt = try container.decodeIfPresent(Date.self, forKey: .updatedAt)
        self.tags = try container.decodeIfPresent(JSONValue.self, forKey: .tags)
        self.metadata = try container.decodeIfPresent([String: String].self, forKey: .metadata)
        self.allMetadata = try container.decode([String: [String: String]].self, forKey: .allMetadata)
        self.conversationId = try container.decode(EntityId.self, forKey: .conversationId)
        self.analysis = try container.decode(ConversationAnalysis.self, forKey: .analysis)
        self.summary = try container.decode(ConversationSummary.self, forKey: .summary)
        self.deleted = try container.decode(Bool.self, forKey: .deleted)
        self.open = try container.decode(Bool.self, forKey: .open)
        self.llmEnabled = try container.decode(Bool.self, forKey: .llmEnabled)
        self.simulationContext = try container.decodeIfPresent(SimulationContext.self, forKey: .simulationContext)
        self.messages = try container.decode([ConversationMessageResponse].self, forKey: .messages)
        self.attachments = try container.decode([AttachmentResponse].self, forKey: .attachments)
        self.additionalProperties = try decoder.decodeAdditionalProperties(using: CodingKeys.self)
    }

    public func encode(to encoder: Encoder) throws -> Void {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try encoder.encodeAdditionalProperties(self.additionalProperties)
        try container.encodeIfPresent(self.responseConfig, forKey: .responseConfig)
        try container.encodeIfPresent(self.subject, forKey: .subject)
        try container.encodeIfPresent(self.url, forKey: .url)
        try container.encodeIfPresent(self.createdAt, forKey: .createdAt)
        try container.encodeIfPresent(self.updatedAt, forKey: .updatedAt)
        try container.encodeIfPresent(self.tags, forKey: .tags)
        try container.encodeIfPresent(self.metadata, forKey: .metadata)
        try container.encode(self.allMetadata, forKey: .allMetadata)
        try container.encode(self.conversationId, forKey: .conversationId)
        try container.encode(self.analysis, forKey: .analysis)
        try container.encode(self.summary, forKey: .summary)
        try container.encode(self.deleted, forKey: .deleted)
        try container.encode(self.open, forKey: .open)
        try container.encode(self.llmEnabled, forKey: .llmEnabled)
        try container.encodeIfPresent(self.simulationContext, forKey: .simulationContext)
        try container.encode(self.messages, forKey: .messages)
        try container.encode(self.attachments, forKey: .attachments)
    }

    /// Keys for encoding/decoding struct properties.
    enum CodingKeys: String, CodingKey, CaseIterable {
        case responseConfig
        case subject
        case url
        case createdAt
        case updatedAt
        case tags
        case metadata
        case allMetadata
        case conversationId
        case analysis
        case summary
        case deleted
        case open
        case llmEnabled
        case simulationContext
        case messages
        case attachments
    }
}